# Problema

Em meados da década de 1990, os microcomputadores pessoais começaram a se tornar acessíveis para o público geral. Nessa época, contudo, o acesso à internet estava longe de ser uma realidade.
A indústria de _software_ se concentrava majoritariamente na produção de "_software_ de caixinha" ou "de prateleira": executáveis auto-contidos, que rodavam apenas localmente e cuja arquitetura ficou conhecida como arquitetura de monolito.
Desde então, com a expansão da computação, da internet, da inteligência artificial e IoT, a arquitetura e o processo de desenvolvimento de software passaram por grande transformação, inevitavelmente ganhando  bastante complexidade.

Na época do software de caixinha, um único programador era capaz de produzir e entregar um sistema completo, desde a interface gráfica até o armazenamento da informação.
Para isso, bastava o conhecimento em uma única linguagem de programação, sendo que -dependendo da forma de armazenamento da informação- até mesmo o conhecimento em banco de dados poderia ser dispensável.

Agora vejamos a quantidade de tecnologias envolvidas no processo de desenvolvimento de software moderno:
* Linguagem de programação para backend
* Script de gerenciamento de dependências
* Script de automação de build
* Bibliotecas de testes unitários, de interfaces, de comportamento, de integração, etc.
* Ferramenta de análise e qualidade de código
* Ferramenta de entrega contínua
* Ferramenta de versionamento de código
* Ferramenta de gerenciamento de identidades, autenticação e autorização
* Sistema gerenciador de bancos de dados e linguagem de consulta
* Biblioteca de mapeamento objeto-relacional
* Plataforma para gerenciamento de aplicações, objetos e bancos de dados na nuvem
* Biblioteca para construção de endpoints 
* Biblioteca para documentação de serviços
* Scripts para hooks de implantação
* Linguagem de programação para frontend
* Linguagem de programação para dispositivos móveis
* Ferramenta para integração de aplicações por mensageria ou streams
* Ferramenta de monitoramento de aplicações
* Script para provisionamento de máquinas virtuais
* Script para orquestração de máquinas virtuais e balanceamento de carga

Dependendo das peculiaridades do projeto, outros conhecimentos podem ser necessários, como ferramentas de indexação de documentos, assinatura digital, técnicas de _machine leargning_, etc.
Na prática, o desenvolvedor está cada vez mais distante de ser capaz de desenvolver uma aplicação sozinho.
Os chamados desenvolvedores _full stack_ e _devops_ são apenas um sonho utópico dos gestores e investidores
Tais perfis são extremamente raros e valiosos
Quase a totalidade daqueles que se dizem enquadrar nesses perfis não passam de detentores de conhecimento superficial dessas tecnologias

# Motivação

E que diferença isso faz pra você?




# Introdução à gestão de projetos

* Um projeto é um esforço temporário que tem como objetivo criar um resultado único e inovador.
* Nesse sentido, um projeto se difere de uma operação.
* Como o escopo deste curso é voltado ao desenvolvimento de _software_, o resultado -evidentemente- será um sistema computacional

* Desde a década de 1960, gerentes de projeto de todo o mundo e de diferentes indústrias começaram a compartilhar conhecimento sobre melhores práticas no gerenciamento de projeto
* Isso resultou na elaboração de um guia: o PMBOK, publicado pela primeira vez em 1996; já se encontra em sua 6ª edição
* O guia é organizado em 10 disciplinas: integração, escopo, prazo, custo, riscos, qualidade, comunicação, partes interessadas, aquisições e recursos humanos
* Neste curso, trataremos apenas da gestão do escopo como ponto de partida para o entendimento da arquiteura 
* O PMBOK é um guia de referência e pode ser adaptado a diferentes processos, indústrias e portes de projetos
* Historicamente, a indústria de software encontrou muitos problemas com processos mais robustos, porque:
  * O sofware demorava muito pra ser entregue e nem sempre atendia às expectativas das partes interessadas
  * O mercado mudava com muito dinamismo, de modo que , quando o software estava pronto, já não atendia às demanadas originais
  * Havia muitos problemas de especificação
* Contudo, o PMBOK é apenas um guia e pode ser adaptado conforme a necessidade, o que permitiu o nascimento de novos processos de desenvolvimento

